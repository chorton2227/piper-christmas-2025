<!DOCTYPE html>
<html lang="en">
<head><meta charset="UTF-8" /><title>Lesson 4.14 Answer Key – Testing & Bug Fixes</title>
<style>
 body{ font-family: system-ui,sans-serif; margin:0; background:#112; color:#eef; }
 header{ background:#1b3d55; padding:.9rem 1.2rem; display:flex; align-items:center; gap:1rem; }
 button{ cursor:pointer; font:inherit; }
 .container{ padding:1rem 1.4rem; }
 .pass{ color:#4caf50; }
 .fail{ color:#f44336; }
 pre{ background:#223; padding:.75rem; overflow:auto; border-radius:8px; }
 .summary{ font-weight:bold; margin-top:.75rem; }
 .section{ margin-bottom:1.5rem; }
 .anomaly{ color:#ffc107; }
 .coverage-zero{ color:#ff9800; font-weight:bold; }
 .grid{ display:grid; gap:.6rem; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); }
</style></head>
<body>
<header>
  <button id="runAll">Run All Tests</button>
  <button id="simulateBtn">Simulate 25 Hands</button>
  <button id="showCoverage">Show Coverage</button>
</header>
<div class="container">
  <h1>Testing & Bug Fixes – Answer Key</h1>
  <div id="unitPanel" class="section">
    <h2>Unit Tests</h2>
    <div id="unitOutput"></div>
  </div>
  <div id="simPanel" class="section">
    <h2>Simulation</h2>
    <div id="simOutput"></div>
  </div>
  <div id="coveragePanel" class="section">
    <h2>Coverage Approximation</h2>
    <div id="coverageOutput"></div>
  </div>
  <div class="section">
    <h2>Bug Log (Sample)</h2>
    <pre id="bugLog"></pre>
  </div>
</div>
<script>
// ----------------- Core Logic (Simplified) -----------------
function createDeck(){ const suits=['H','D','C','S']; const ranks=['2','3','4','5','6','7','8','9','T','J','Q','K','A']; const deck=[]; suits.forEach(s=>ranks.forEach(r=>deck.push(r+s))); coverage.hit('deck-build'); return deck; }
function shuffle(deck, rnd=Math.random){ for(let i=deck.length-1;i>0;i--){ const j=Math.floor(rnd()*(i+1)); [deck[i],deck[j]]=[deck[j],deck[i]]; coverage.hit('deck-shuffle-loop'); } return deck; }
function evaluateHighCard(hand){ // placeholder: higher rank index wins
  const order='23456789TJQKA'; let best=-1; hand.forEach(c=>{ const r=c[0]; const idx=order.indexOf(r); if(idx>best){ best=idx; coverage.hit('eval-new-best'); } }); return best; }
// ----------------- Coverage Helper -----------------
const coverage={ map:{}, hit(id){ this.map[id]=(this.map[id]||0)+1; } };
// ----------------- Assertion Helpers -----------------
function assert(cond,msg){ if(!cond) throw new Error(msg); }
function assertEqual(a,b,msg){ if(a!==b) throw new Error(`${msg} (expected ${b}, got ${a})`); }
// ----------------- Unit Tests -----------------
const unitTests=[];
unitTests.push({ name:'createDeck returns 52 unique cards', fn(){ const d=createDeck(); assertEqual(d.length,52,'Deck length mismatch'); const set=new Set(d); assertEqual(set.size,52,'Duplicate card'); }});
unitTests.push({ name:'shuffle preserves card count', fn(){ const d=createDeck(); shuffle(d); assertEqual(d.length,52,'Card count changed'); }});
unitTests.push({ name:'evaluateHighCard ranks A > 2', fn(){ const scoreA=evaluateHighCard(['AH']); const score2=evaluateHighCard(['2H']); assert(scoreA>score2,'Ace not higher than 2'); }});
// Regression examples
unitTests.push({ name:'No duplicate pot award (regression placeholder)', fn(){ coverage.hit('regression-pot'); assert(true,'Placeholder passes'); }});
// Added regression tests targeting recent fixes
unitTests.push({ name:'All-In disables buttons during auto-deal', fn(){
  // Simulate by calling a dummy disableActionButtons and checking state
  const buttons = [{disabled:false},{disabled:false},{disabled:false}];
  function disableActionButtons(){ buttons.forEach(b=>b.disabled=true); }
  function enableActionButtons(){ buttons.forEach(b=>b.disabled=false); }
  disableActionButtons();
  assert(buttons.every(b=>b.disabled===true), 'Buttons not disabled');
  enableActionButtons();
  assert(buttons.every(b=>b.disabled===false), 'Buttons not re-enabled');
}});
unitTests.push({ name:'Single pot award per hand', fn(){
  let player=0, dealer=0, pot=200; let awarded=0;
  function endHandOnce(winner){ if(awarded>0) throw new Error('Pot awarded twice'); awarded++; if(winner==='player') player+=pot; else dealer+=pot; pot=0; }
  endHandOnce('player');
  assertEqual(awarded,1,'Award count mismatch');
  assertEqual(pot,0,'Pot not zeroed');
}});

function runUnitTests(){ const out=document.getElementById('unitOutput'); out.innerHTML=''; let pass=0, fail=0; unitTests.forEach(t=>{ try{ t.fn(); pass++; out.innerHTML += `<div class='pass'>PASS: ${t.name}</div>`; } catch(e){ fail++; out.innerHTML += `<div class='fail'>FAIL: ${t.name} – ${e.message}</div>`; } }); out.innerHTML += `<div class='summary'>${pass} passed, ${fail} failed</div>`; }
// ----------------- Simulation -----------------
function simulateHands(count=10){ const simOut=document.getElementById('simOutput'); simOut.innerHTML=''; const anomalies=[]; for(let h=0; h<count; h++){ const deck=shuffle(createDeck().slice()); // deal two hands of 2 cards high-card compare
    const player=[deck.pop(), deck.pop()]; const dealer=[deck.pop(), deck.pop()]; coverage.hit('deal-hand'); const pScore=evaluateHighCard(player); const dScore=evaluateHighCard(dealer); let winner='player'; if(dScore>pScore) winner='dealer'; else if(dScore===pScore){ winner='tie'; }
    // anomaly: impossible condition (example) if more than 2 same cards
    const allCards=[...player,...dealer]; const set=new Set(allCards); if(set.size!==4){ anomalies.push({ type:'duplicate-card', hand:h+1 }); coverage.hit('anomaly-duplicate'); }
  }
  simOut.innerHTML += `<p>Simulated ${count} mini hands.</p>`;
  if(anomalies.length){ simOut.innerHTML += '<h3>Anomalies</h3>' + anomalies.map(a=>`<div class='anomaly'>${a.type} (hand ${a.hand})</div>`).join(''); }
  else simOut.innerHTML += '<p>No anomalies detected.</p>';
}
// ----------------- Coverage Report -----------------
function showCoverage(){ const out=document.getElementById('coverageOutput'); out.innerHTML=''; const entries=Object.entries(coverage.map); if(!entries.length){ out.textContent='No coverage data yet. Run tests or simulation.'; return; } entries.forEach(([id,c])=>{ out.innerHTML += `<div class='cov-item ${c===0?'coverage-zero':''}'>${id}: ${c}</div>`; }); const zero=entries.filter(e=>e[1]===0).length; out.innerHTML += `<p><strong>${zero} branches with zero hits.</strong></p>`; }
// ----------------- Bug Log Sample -----------------
const bugLogSample = `| ID | Title | Severity | Status | Steps | Expected | Actual | Date |\n| 1 | Duplicate pot award | High | Fixed | Trigger all-in then showdown | Pot awarded once | Pot awarded twice | 2025-11-18 |\n| 2 | Action buttons active during all-in | Medium | Fixed | Player all-in then phases auto-deal | Buttons disabled until next hand | Buttons clickable mid-sequence | 2025-11-20 |`;
document.getElementById('bugLog').textContent = bugLogSample;
// ----------------- Wire Buttons -----------------
document.getElementById('runAll').addEventListener('click', runUnitTests);
document.getElementById('simulateBtn').addEventListener('click', ()=>simulateHands(25));
document.getElementById('showCoverage').addEventListener('click', showCoverage);
// Auto initial run
runUnitTests();
</script>
</body>
</html>